<?php
/**
 * Restarts the Swoole server (by killing the start_server.php file and executing it again)
 * when there is a change in files in the project folder
 * @author julia@azonmedia.com
 * @created Sep 12, 2019
 * @see http://gitlab.guzaba.org/root/guzaba-framework-2/issues/14
 */ 
declare(strict_types=1);

namespace Guzaba2\Platform;

use GuzabaPlatform\Platform\Application\GuzabaPlatform;
use Azonmedia\Registry\Registry;
use Azonmedia\Registry\RegistryBackendEnv;
use Guzaba2\Kernel\Kernel;
use Guzaba2\Registry\Interfaces\RegistryInterface;
use Monolog\Formatter\LineFormatter;
use Monolog\Handler\StreamHandler;
use Monolog\Logger;
use Psr\Log\LogLevel;

$autoload_path = realpath(__DIR__ . '/../../vendor/autoload.php');
require_once($autoload_path);


$app_dir = realpath(dirname(__FILE__).DIRECTORY_SEPARATOR.'..'. DIRECTORY_SEPARATOR);

//folder where start scripts reside
$working_dir = $app_dir.DIRECTORY_SEPARATOR.'bin';

//folder that will be monitored fo changes
$watch_directory = $app_dir.DIRECTORY_SEPARATOR.'src';

//array that will hold all child process ids of the main process, generated by $get_process_children()
$process_ids = array();

//current process
$process = '';

//proc_open() settings
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
   2 => array("file", "{$app_dir}/logs/continuous_server_errors.txt", "a") // stderr is a file to write to
);

//events that will trigger restart of the process
$supported_events = IN_DELETE | IN_MODIFY;

/**
 * Local logger function
 * @param string $file_name - the log filename, without extension
 * @param string $text - the text that will be written in the log file
 */ 
$my_logger = function(string $file_name, string $text): void
{
    $logfile = realpath(getcwd());
    $logfile.= '/app/logs/' . $file_name . '.txt';
    $ret = (bool) file_put_contents($logfile, $text.PHP_EOL.PHP_EOL.PHP_EOL, FILE_APPEND);
};


/**
 * Recursive function to get all child process ids of the main process  
 * @param int $search_pid - main process id whose children will be searched
 */ 
$get_process_children = function (int $search_pid) use (&$get_process_children, &$process_ids, $my_logger)
{
    if (empty($search_pid)) {
        return false;
    }

    $ppid_result = shell_exec("ps -o pid --no-heading --ppid $search_pid");

    if (!empty($ppid_result)) {
        $pids = preg_split('/\s+/', $ppid_result);
        foreach($pids as $pid) {
            if(is_numeric($pid)) {
                $process_ids[] = $pid;
                $get_process_children((int)$pid);
            }
        }
    } else {
        return true;
    }
};


/**
 * Function that runs the start_server.php script
 * If there is an already running start_server process it will be killed first
 */ 
$main_process = function() use (&$process, &$pipes, &$process_ids, $descriptorspec, $working_dir, $get_process_children, $my_logger) : void
{
    //if there is an already running process, stop it
    if (is_resource($process)) {
        $status = proc_get_status($process);
        if ($status['running'] == true) {           
            //close all pipes
            fclose($pipes[0]); //stdin
            fclose($pipes[1]); //stdout
            
            //get the pid of the process that has to be killed
            $ppid = $status['pid'];
            
            //find children of the current process
            $get_process_children($ppid);
            
            if (is_array($process_ids)) {
                //reverse the array so we start with the child that was created last
                $process_children = array_reverse($process_ids);
                                
                foreach ($process_children as $unwanted_child) {
                    $result = posix_kill((int)$unwanted_child, 15);
                }
                //unset the array so it's ready for the next round
                $process_ids = array();
            }
            //terminate the main process
            proc_terminate($process);
            echo "Restarting Server. \n";
        }
        //the waiting time is needed because currently the main process is not killed immediately, it is turned into a defunct process and it takes some time for it to die
        sleep(5);
    }

    //start the server asynchronously
    $process = proc_open('exec php start_server.php', $descriptorspec, $pipes, $working_dir);

    if (is_resource($process)) {
        stream_set_blocking($pipes[0], FALSE);
        stream_set_blocking($pipes[1], FALSE);
    }
};

//initial start of the swoole server
$main_process();

$ino_inst = inotify_init();
stream_set_blocking($ino_inst, FALSE);

$rii = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($watch_directory));

$folders = array(); 
$inotify_inst = array();
//add watches to all folders
foreach ($rii as $pathname => $fileinfo) {
    if ($fileinfo->isDir()) { 
        //git and logs folders are excluded
        $pos = strpos($pathname, '.git');
        if ($pos === false) {
            $pos = strpos($pathname, 'logs');
            if ($pos === false) {
                $folders[] = realpath($fileinfo->getPathname()); 
                $inotify_inst[] = inotify_add_watch($ino_inst, realpath($fileinfo->getPathname()), $supported_events);
            }
        }
    }
}

//if there is an event restart the server
while (true) {
    $events = inotify_read($ino_inst);
    if ($events) {
        $main_process();
    }
    //printing output from main_process file
    if (is_resource($process)) {
        while ($s = fgets($pipes[1])) {
            print $s;
            flush();
        }
    }
    usleep(50000);
}

foreach ($inotify_inst as $item) {
    inotify_rm_watch($ino_inst, $item);
}

// close inotify instance
fclose($ino_inst);
